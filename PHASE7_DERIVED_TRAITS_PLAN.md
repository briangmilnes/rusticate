# Phase 7: Detect Derived Trait Methods

## Problem Statement

The `review-test-functions` tool currently misses methods that are automatically generated by `#[derive(...)]` attributes. For example:

```rust
#[derive(Clone, Debug, PartialEq)]
pub struct MyType {
    field: i32,
}
```

This generates three public methods:
- `MyType::clone(&self) -> Self`
- `MyType::fmt(&self, f: &mut Formatter) -> Result` (for Debug)
- `MyType::eq(&self, other: &Self) -> bool`

**Current behavior:** Tool reports 0 public functions for this struct  
**Expected behavior:** Tool should report 3 public functions (clone, fmt, eq)

---

## Impact

**Current apas-ai results:**
- 2,360 functions detected
- 99.6% coverage

**After Phase 7 (estimated):**
- ~2,500-2,700 functions detected (adding 140-340 derived methods)
- Coverage may drop to ~97-98% (many derived Clone::clone likely untested)

---

## Common Derived Traits

### Standard Library Derives

| Trait | Methods Generated | Signature |
|-------|-------------------|-----------|
| `Clone` | `clone` | `fn clone(&self) -> Self` |
| `Copy` | *(no methods, marker trait)* | - |
| `Debug` | `fmt` | `fn fmt(&self, f: &mut Formatter) -> Result` |
| `Default` | `default` | `fn default() -> Self` |
| `PartialEq` | `eq`, `ne` | `fn eq(&self, other: &Self) -> bool` |
| `Eq` | *(no methods, extends PartialEq)* | - |
| `PartialOrd` | `partial_cmp`, `lt`, `le`, `gt`, `ge` | `fn partial_cmp(&self, other: &Self) -> Option<Ordering>` |
| `Ord` | `cmp` | `fn cmp(&self, other: &Self) -> Ordering` |
| `Hash` | `hash` | `fn hash<H: Hasher>(&self, state: &mut H)` |

### Custom Derives (common in apas-ai)

- `Sequence` - likely generates sequence operations
- `Collection` - likely generates collection operations  
- `Functor`, `Applicative`, `Monad` - functional programming traits

**Strategy:** Start with standard library derives only, add custom derives later.

---

## Implementation Plan

### Phase 7.1: Detect `#[derive(...)]` Attributes

**Goal:** Find all structs/enums with derive attributes.

**AST Approach:**
```rust
fn find_derived_traits(file: &Path) -> Result<Vec<DerivedType>> {
    let content = fs::read_to_string(file)?;
    let parsed = SourceFile::parse(&content, Edition::Edition2021);
    let root = parsed.tree().syntax();
    
    let mut derived_types = Vec::new();
    
    // Find STRUCT and ENUM nodes
    for node in root.descendants() {
        if node.kind() == SyntaxKind::STRUCT || node.kind() == SyntaxKind::ENUM {
            if let Some(struct_def) = ast::Struct::cast(node.clone())
                .or_else(|| ast::Enum::cast(node.clone()).map(|e| /* convert to Struct-like */))
            {
                // Check for derive attributes
                for attr in struct_def.attrs() {
                    if let Some(path) = attr.path() {
                        if path.to_string() == "derive" {
                            // Parse the derive list
                            if let Some(token_tree) = attr.token_tree() {
                                let traits = parse_derive_list(&token_tree);
                                // Store type name + traits
                            }
                        }
                    }
                }
            }
        }
    }
    
    Ok(derived_types)
}
```

**Data Structure:**
```rust
#[derive(Debug, Clone)]
struct DerivedType {
    type_name: String,           // "MyType"
    file: PathBuf,
    line: usize,
    derived_traits: Vec<String>, // ["Clone", "Debug", "PartialEq"]
    is_public: bool,             // Only track if type is pub
}
```

---

### Phase 7.2: Parse Derive Attribute List

**Goal:** Extract trait names from `#[derive(Clone, Debug, PartialEq)]`.

**AST Approach:**
```rust
fn parse_derive_list(token_tree: &ast::TokenTree) -> Vec<String> {
    let mut traits = Vec::new();
    
    // Traverse token tree looking for IDENT tokens
    for token in token_tree.syntax().descendants_with_tokens() {
        if token.kind() == SyntaxKind::IDENT {
            let trait_name = token.to_string();
            // Skip keywords like "pub", "crate"
            if is_trait_name(&trait_name) {
                traits.push(trait_name);
            }
        }
    }
    
    traits
}

fn is_trait_name(name: &str) -> bool {
    // Common derives
    matches!(name, 
        "Clone" | "Copy" | "Debug" | "Default" | 
        "PartialEq" | "Eq" | "PartialOrd" | "Ord" | 
        "Hash" | "Display" | "FromStr"
    )
}
```

**Edge Cases:**
- Multiple attributes: `#[derive(Clone)] #[derive(Debug)]`
- Complex paths: `#[derive(serde::Serialize)]` → extract "Serialize"
- Grouped: `#[derive(Clone, Copy, Debug)]`

---

### Phase 7.3: Trait-to-Method Mapping

**Goal:** Map each trait to its generated methods.

**Implementation:**
```rust
fn get_trait_methods(trait_name: &str) -> Vec<TraitMethod> {
    match trait_name {
        "Clone" => vec![
            TraitMethod {
                name: "clone",
                trait_name: "Clone",
            }
        ],
        "Debug" => vec![
            TraitMethod {
                name: "fmt",
                trait_name: "Debug",
            }
        ],
        "Default" => vec![
            TraitMethod {
                name: "default",
                trait_name: "Default",
            }
        ],
        "PartialEq" => vec![
            TraitMethod { name: "eq", trait_name: "PartialEq" },
            TraitMethod { name: "ne", trait_name: "PartialEq" },
        ],
        "PartialOrd" => vec![
            TraitMethod { name: "partial_cmp", trait_name: "PartialOrd" },
            TraitMethod { name: "lt", trait_name: "PartialOrd" },
            TraitMethod { name: "le", trait_name: "PartialOrd" },
            TraitMethod { name: "gt", trait_name: "PartialOrd" },
            TraitMethod { name: "ge", trait_name: "PartialOrd" },
        ],
        "Ord" => vec![
            TraitMethod { name: "cmp", trait_name: "Ord" },
        ],
        "Hash" => vec![
            TraitMethod { name: "hash", trait_name: "Hash" },
        ],
        _ => vec![], // Unknown or custom derive
    }
}

#[derive(Debug, Clone)]
struct TraitMethod {
    name: &'static str,
    trait_name: &'static str,
}
```

---

### Phase 7.4: Generate Synthetic PublicFunction Entries

**Goal:** For each derived trait, create a `PublicFunction` entry.

**Implementation:**
```rust
fn generate_derived_functions(
    derived_types: Vec<DerivedType>
) -> Vec<PublicFunction> {
    let mut functions = Vec::new();
    
    for derived_type in derived_types {
        if !derived_type.is_public {
            continue; // Skip private types
        }
        
        for trait_name in &derived_type.derived_traits {
            for method in get_trait_methods(trait_name) {
                functions.push(PublicFunction {
                    name: method.name.to_string(),
                    file: derived_type.file.clone(),
                    line: derived_type.line,
                    impl_type: Some(derived_type.type_name.clone()),
                });
            }
        }
    }
    
    functions
}
```

**Integration:**
```rust
// In main()
let mut all_functions = find_public_functions(&src_files)?;

// Add derived functions
let derived_types = find_derived_traits(&src_files)?;
let derived_functions = generate_derived_functions(derived_types);
all_functions.extend(derived_functions);
```

---

### Phase 7.5: Mark Derived Methods in Output

**Goal:** Distinguish derived methods in the report.

**Approach 1: Add DerivedTrait to CoverageSource**
```rust
enum CoverageSource {
    Direct,
    DisplayTrait,
    DebugTrait,
    PartialEqTrait,
    TransitiveCoverage(String),
    DerivedTrait(String),  // NEW: "Clone", "Debug", etc.
}
```

**Approach 2: Add metadata to PublicFunction**
```rust
struct PublicFunction {
    name: String,
    file: PathBuf,
    line: usize,
    impl_type: Option<String>,
    is_derived: bool,          // NEW
    derived_from: Option<String>, // NEW: "Clone", "Debug", etc.
}
```

**Output format:**
```
Before:
src/Types.rs:50:  MyType::clone - NO TEST COVERAGE

After:
src/Types.rs:50:  MyType::clone - NO TEST COVERAGE (derived Clone)
```

Or if tested:
```
src/Types.rs:50:  MyType::clone - 5 call(s) in 2 test file(s) (derived Clone)
```

---

### Phase 7.6: Test on apas-ai

**Expected results:**

1. **Find derived types:**
```bash
grep -r "#\[derive" APAS-AI-copy/apas-ai/src/ | wc -l
# Estimate: 100-200 structs/enums with derives
```

2. **Estimated new functions:**
```
- Clone: ~150 types × 1 method = 150 functions
- Debug: ~100 types × 1 method = 100 functions  
- PartialEq: ~50 types × 2 methods = 100 functions
- Default: ~30 types × 1 method = 30 functions
- Total: ~380 new functions
```

3. **Coverage impact:**
```
Before: 2,360 functions, 2,350 tested (99.6%)
After:  2,740 functions, 2,400 tested (87.6%)
  - 340 new derived functions
  - ~50 tested (via direct calls like .clone())
  - ~290 untested (need coverage)
```

4. **Sample output:**
```
================================================================================
PUBLIC FUNCTIONS WITHOUT TEST COVERAGE:
================================================================================

src/Chap05/MappingStEph.rs:15:  MappingStEph::clone - NO TEST COVERAGE (derived Clone)
src/Chap05/MappingStEph.rs:15:  MappingStEph::default - NO TEST COVERAGE (derived Default)
src/Chap06/DirGraphStEph.rs:20:  DirGraphStEph::clone - NO TEST COVERAGE (derived Clone)
...

================================================================================
SUMMARY:
  Total public functions: 2,740
  Functions with test coverage: 2,400 (87.6%)
  Functions without test coverage: 340 (12.4%)
    - 290 derived trait methods
    - 50 explicit methods
================================================================================
```

---

### Phase 7.7: Update Summary

**Goal:** Distinguish derived vs explicit functions in summary.

**Enhanced summary:**
```rust
let explicit_count = all_functions.iter()
    .filter(|f| !f.is_derived)
    .count();

let derived_count = all_functions.iter()
    .filter(|f| f.is_derived)
    .count();

let untested_explicit = untested.iter()
    .filter(|f| !f.function.is_derived)
    .count();

let untested_derived = untested.iter()
    .filter(|f| f.function.is_derived)
    .count();

println!("SUMMARY:");
println!("  Total public functions: {} ({} explicit + {} derived)", 
         total, explicit_count, derived_count);
println!("  Functions with test coverage: {} ({:.1}%)", tested_count, coverage_pct);
println!("  Functions without test coverage: {} ({:.1}%)", untested_count, untested_pct);
if untested_derived > 0 {
    println!("    - {} derived trait methods", untested_derived);
}
if untested_explicit > 0 {
    println!("    - {} explicit methods", untested_explicit);
}
```

---

## Edge Cases

### 1. Generic Types
```rust
#[derive(Clone, Debug)]
pub struct MyType<T> {
    field: T,
}
```

**Solution:** Strip generics from type name (already done in `find_trait_implementations`).

### 2. Conditional Derives
```rust
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct MyType {
    field: i32,
}
```

**Solution:** Ignore `cfg_attr` for now, only process direct `derive`.

### 3. Custom Derive Macros
```rust
#[derive(Sequence)]  // Custom procedural macro
pub struct MyType {
    field: i32,
}
```

**Solution:** Skip unknown derives, only process standard library traits.

### 4. Manual Implementations Override
```rust
#[derive(Clone, Debug)]
pub struct MyType {
    field: i32,
}

impl Clone for MyType {
    fn clone(&self) -> Self {
        // Custom implementation
    }
}
```

**Solution:** Check if manual impl exists before adding derived method:
```rust
// In find_public_functions, collect all manually implemented traits
let manual_impls: HashSet<(String, String)> = ...; // (type, trait)

// In generate_derived_functions, skip if manually implemented
if manual_impls.contains(&(type_name, trait_name)) {
    continue;
}
```

### 5. Derive on Private Types
```rust
#[derive(Clone)]
struct PrivateType {  // No 'pub'
    field: i32,
}
```

**Solution:** Only process derives on `pub` structs/enums (check visibility).

---

## Testing Strategy

### Test 1: Detect Single Derive
```rust
// test_file.rs
#[derive(Clone)]
pub struct Simple {
    x: i32,
}
```

**Expected:** 1 function `Simple::clone`

### Test 2: Detect Multiple Derives
```rust
#[derive(Clone, Debug, PartialEq, Default)]
pub struct Multi {
    x: i32,
}
```

**Expected:** 4 functions (clone, fmt, eq, ne, default)

### Test 3: Detect on Enum
```rust
#[derive(Clone, Debug)]
pub enum MyEnum {
    A,
    B,
}
```

**Expected:** 2 functions (clone, fmt)

### Test 4: Skip Private Types
```rust
#[derive(Clone)]
struct Private {
    x: i32,
}
```

**Expected:** 0 functions

### Test 5: Detect Coverage
```rust
// lib.rs
#[derive(Clone)]
pub struct Tested {
    x: i32,
}

// tests/test.rs
#[test]
fn test_clone() {
    let t = Tested { x: 5 };
    let t2 = t.clone();
    assert_eq!(t.x, t2.x);
}
```

**Expected:** `Tested::clone - 1 call(s) in 1 test file(s) (derived Clone)`

---

## Performance Considerations

**Current performance:**
- 2,360 functions analyzed in ~2.1 seconds

**After Phase 7 (estimated):**
- 2,740 functions analyzed in ~2.3 seconds
- Derive detection adds ~200ms overhead
- Acceptable for CI/CD

---

## Success Criteria

✅ Detect all `#[derive(...)]` attributes on public types  
✅ Parse trait lists correctly (Clone, Debug, PartialEq, etc.)  
✅ Generate synthetic PublicFunction entries for derived methods  
✅ Report coverage for derived methods (tested vs untested)  
✅ Distinguish derived methods in output  
✅ Enhanced summary shows explicit vs derived counts  
✅ Zero false positives (don't add methods from unknown derives)  
✅ Handle edge cases (generics, private types, manual impls)  
✅ Performance acceptable (<3 seconds for apas-ai)  

---

## Future Enhancements (Not in Phase 7)

1. **Custom Derive Support**
   - Add registry of known custom derives
   - Map to their generated methods

2. **Cross-Crate Derive Detection**
   - Detect derives from external crates (serde, etc.)

3. **Derive Macro Expansion**
   - Use rust-analyzer to expand derive macros
   - Get exact method signatures

4. **Smart Coverage Hints**
   - Suggest specific tests for untested Clone::clone
   - "Add: let x2 = x.clone(); assert_eq!(x, x2);"

---

## Implementation Timeline

**Phase 7 Breakdown:**
- 7.1-7.2: Detect and parse derives (~30 min)
- 7.3: Trait-to-method mapping (~15 min)
- 7.4: Generate synthetic functions (~20 min)
- 7.5: Mark derived in output (~10 min)
- 7.6: Test on apas-ai (~15 min)
- 7.7: Update summary (~10 min)

**Total:** ~1.5-2 hours

---

## Risk Assessment

**Low Risk:**
- Standard library derives are well-defined
- AST approach is reliable
- No code modification (review-only)

**Potential Issues:**
- False positives from unknown derives → Mitigated by whitelist
- Performance degradation → Acceptable overhead
- Coverage drop looks bad → Provide clear context in summary

**Recommendation:** Proceed with implementation.

