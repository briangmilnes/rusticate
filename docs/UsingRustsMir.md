# Using Rust's MIR (Mid-level Intermediate Representation)

## Overview

MIR is Rust's fully-typed intermediate representation, generated after type checking but before code generation. It contains complete type information and fully-qualified function calls, making it ideal for analyzing stdlib usage.

## Generating MIR

```bash
# For a single crate
RUSTFLAGS="--emit=mir" cargo check

# Or use rusticate-mirify for batch processing
rusticate-mirify -C ~/projects/RustCodebases -j 6
```

MIR files are written to `target/debug/deps/*.mir`.

## MIR Text Format

The text format is designed for humans, not machines:

```
// WARNING: This output format is intended for human consumers only
// and is subject to change without notice. Knock yourself out.
```

### Structure

```
static INIT: std::sync::Once = {
    let mut _0: std::sync::Once;

    bb0: {
        _0 = std::sync::Once::new() -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn cached() -> bool {
    let mut _0: bool;
    let _1: ();
    let mut _2: &std::sync::Once;

    bb0: {
        _2 = const {alloc1: &std::sync::Once};
        _1 = std::sync::Once::call_once::<{closure@src/lib.rs:18:20}>(move _2, ...) -> [return: bb1, unwind continue];
    }
    ...
}
```

### Key Elements

- **Statics**: `static NAME: Type = { ... }`
- **Functions**: `fn name(args) -> ReturnType { ... }`
- **Basic blocks**: `bb0:`, `bb1:`, etc.
- **Locals**: `let mut _N: Type;`
- **Assignments**: `_N = expression`
- **Function calls**: `Type::method(args) -> [return: bbN, unwind ...]`

### Fully Qualified Paths

Function calls include complete paths:

```
std::sync::Once::new()
std::sync::Once::call_once::<{closure@src/lib.rs:18:20}>
core::str::<impl str>::ends_with::<&str>
<u32 as From<u16>>::from
core::num::<impl u8>::saturating_sub
std::cmp::min::<usize>
```

## Parsing MIR for Stdlib Usage

The text format is regular enough for line-based parsing:

```rust
// Pattern: _N = fully::qualified::path(args) -> [return: bbN, ...]
for line in content.lines() {
    if line.contains("std::") || line.contains("core::") || line.contains("alloc::") {
        if let Some(eq_pos) = line.find('=') {
            // Extract function call between '=' and '('
            ...
        }
    }
}
```

### Example Output

From `rusticate-analyze-modules -M`:

```
=== Stdlib Modules Used ===
    6292 core::fmt
    4377 core::sync
    1880 std::os
    1059 std::sync

=== Top Stdlib Function Calls ===
    6180 core::fmt::rt
    4377 core::sync::atomic
     873 Formatter::<'_>::write_str
     793 std::sync::atomic
```

## Performance

- 77 MIR files: ~300ms
- ~350 calls/ms throughput
- Pure disk I/O + string parsing

## Limitations

1. **Not stable**: Format may change between rustc versions
2. **Not structured**: No JSON/protobuf schema
3. **Human-oriented**: Contains prose, source paths, closure syntax
4. **Local module confusion**: A local `core` module matches `core::*` patterns

## Alternatives Considered

### stable-mir-json

[runtimeverification/stable-mir-json](https://github.com/runtimeverification/stable-mir-json) provides JSON output:

```json
{
  "functions": [
    [{"NormalSym": "_ZN3std4sync4Once9call_once17h"}]
  ],
  "items": [...]
}
```

Requires:
- Separate compilation tool (not standard `cargo check`)
- Symbol demangling via `rustc-demangle`
- More complex integration

### rustc-demangle

Not needed for text MIR since paths are already human-readable. Only useful for mangled symbols in binary/JSON output.

## Recommendation

For **stdlib usage analysis**: Text MIR works well. Fast, already generated by `cargo check --emit=mir`, parseable with simple regex.

For **ML training data**: Would need structured format. Text MIR is too irregular and version-dependent.

## Tools

- `rusticate-mirify -C <dir>`: Generate MIR for multiple projects
- `rusticate-analyze-modules -M <path>`: Analyze MIR for stdlib usage

